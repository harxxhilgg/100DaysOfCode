## start by creating store

-> mostly one applications has one store (or we can call it single-source-of-truth)

we need `configureStore` there, we can import it from `@reduxjs/toolkit` and we can use it configure store as: `export const store = configureStore({})`.

we need to introduce `reducer` inside store.

till here we haven't created any reducer. to we'll start by creating reducer from here.

## creating slice

now create 2 new folders at: `src/features/todo/` and create a `todoSlice.js` file.

in documentations we call features as slice. both are same.

start by importing `crateSlice` and `nonoid` from `@reduxjs/toolkit`.

to create a Slice, we need 3 things majorly:
  1. `name` (in our project we've used `todo`)
  2. `initialState` (
    like same as useState() - we give here default value, if no value is here then this value will be here always. it can be array, number, etc. (we've taken array).
  )
  3. list of `reducers` (
    list of reducers as we used like addTodo, removeTodo, etc...every reducer must have state and action, 
    here, `state:` this is the initial value
          `action:` this is the value which is going to be updated using a particular id. which is going to be generated by nanoid. also in action, we'll get `action.payload`

    then as we have action of state, then we'll push the text into state using `state.todos.push(todo)`. unlike this we used to take each and every array from state then spreading those arrays and then putting our value and the value will be updated there in Context API. state won't be preserved here. but in Slices, state remains preserved.
  )


then export `reducers` using `export const { addTodo, removeTodo } = todoSlice.actions`. 

as our application has two reducers `addTodo` and `removeTodo` and our Slice name is `todoSlice` and adding `.action` to it means we were exporting default value of state but using `.action` we are exporting the updated value into state and exporting the updated value.

then exporting reducers using `export default todoSlice.reducer`.

then we are goin to `store.js`.

in it, first we are importing `{ configureStore } from '@reduxjs/toolkit'` and `todoReducer` from `todoSlice.js`.

now in `store.js` we are exporting list of our reducers using,
```
export const store = configureStore({
  reducer: todoReducer
})
```
then we're creating components, for this applications, we've two components.

in `AddTodo.jsx`: we have to send value, we use `useDispath()` to acutally send the value. so we declare dispatch like `const dispatch = useDispatch()`.

also created `addTodoHandler` function as we can use it into HTML, like:
```
const addTodoHandler = (e) => {
  e.preventDefault()
  dispatch(addTodo(input))
  setInput('')
}
```
here, 
`e.preventDefault()` will stop doin form submit every time you refresh application.
`dispatch(addTodo(input))` will send the value to be added into todo. here, input is the initial value of the state.


now, create another component called `Todos.jsx` to remove Todo.

inside it, we'll use both `useReducer` and `useSelector`.

`useSelector:` we'll use to select the value and add todo using `const todos = useSelector(state => state.todos)` and removing using dispatch, dispatch basically means sending something.

we can initialize dispatch using `const dispatch = useDispatch()` and add it to onClick event at the `❌` like this. `onClick={() => dispatch(removeTodo(todo.id))}`.

this is how we can use redux-toolkit and alter/add/remove values using useDispatch and useSelector.